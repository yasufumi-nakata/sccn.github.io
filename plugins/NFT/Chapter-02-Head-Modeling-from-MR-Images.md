---
layout: default
parent: NFT
grand_parent: Plugins
render_with_liquid: false

title: Chapter-02-Head-Modeling-from-MR-Images
nav_title: "第2章-MR-Imagesからヘッドモデリング-"
long_title: Chapter-02-Head-Modeling-from-MR-Images
---
ヘッドモデリングのステップは、セグメント化、メッシュ生成、および
スカルプ面での電極位置の共同調整。 ご利用者様も
逆の溶液で使用するソーススペースを生成します
問題。 図2では、MR画像を用いたヘッドモデリングの手順を示します。

![図2:MR画像を用いたヘッドモデリングのステップ](NFM_Toolboox_UsersManual_html_2aaa1b22.gif)

現実的なヘッドモデリングの各ステップは、別のGUIとして実装されています
メインメニューから到達可能なモジュール。 これらのモジュールは、
以下のサブセクション。

セグメント
------------

セグメントの最初のステップは、MRイメージをロードすることです。 入力の入力
分割モジュールは3次元のsagittal T1級のMRイメージです。 イメージ
フォーマットはフォーマットを分析し、voxelのサイズは1×1である必要があります
mm。 このツールボックスのイメージを作成するには、Freesurfer を使うことができます。
ソフトウェア (http://surfer.nmr.mgh.harvard.edu/) 以下を実行する
操作:

1.  浸透補正:
    mri_nu_correct ディレクティブ --i 入力_volume --o output_volume --n 2

2.  入力ボリュームを1 mmのボリュームデータに変換:
    mri_コンバート -i 入力_volume --conform_size 1 --o output_volume

3.  画像をオリエント:
    mri_変換 -i 入力_volume --out_orientation ディレクティブ PSR -ot形式
    -o output_volume(出力)

4.  解析形式で保存:
    mri_変換 -it 解析 -i output_file_name ディレクティブ -otファイル_type
    -o入力_volume

画像が読み込まれると、サギタール、軸、および
冠状のオリエンテーションで、使用することで簡単にスライスを選択することが可能
スクロールバーまたは画像をクリック(図3)。 ディスプレイイメージ
パネルはユーザーがイメージに表示するイメージを選ぶことを可能にします
パネル。 利用できる選択はMRの容積、ろ過された容積またはです
セグメント化のさまざまな段階。

![](NFT_from_MRI_segmentation.png) .....
![図3:セグメント化のためのインターフェイス](NFT_segmentation.png)

セグメンテーションGUIの右側のパネルはセグメンテーションを示しています
順番にボリュームで実行される手順:

1.  異方性ろ過。

2.  スカルプセグメンテーション

3.  脳分割。

4.  外スカルセグメンテーション。

5.  内部の頭蓋骨の区分。


現在のステップは赤で強調されます。 Runボタンを押します。
分節ステップ。 特定のステップを繰り返すことができ、変化
変数および出力の観察。 次のボタンを押し続ける
次のステップへ。 以下は、各セグメンテーションステップの議論です。

### 異方性フィルタリング

異方性ろ過の目的はイメージの質を高めることです。
このフィルタは、エッジを保存しながら画像のSNRを増加させます。
異方性ろ過への入力は反復の数であり、
画像拡散。 5と3のデフォルト値は、ほとんどのMRでうまく動作します
画像。 値が増加するにつれて、画像は鈍化し始めます。 ふりがな
「フィルター」を選択することで、異方性フィルタリングの出力を観察できます。
ディスプレイイメージパネルからのイメージ

### スカルプセグメンテーション

次のステップはスカルプセグメンテーションで、背景を分離します。
イメージ。 scalp のセグメンテーションにユーザ入力はありません。 自動化
閾値アルゴリズムを適用し、結果は観察することができます
「スカルプマスク」を選択

### 脳分割

脳のセグメンテーションは水流されたセグメンテーションアルゴリズムを使用します。
シードポイントから接続されたvoxelsを選択します。 防止のため
脳領域をオーバーフローするアルゴリズム、最も低いポイント
cerebellum はユーザーによって選択する必要があります。 この点はマークする必要があります
スライスの冠状とサギタルビューを使って画像パネルに。 おすすめ
カーソルは cerebellum の一番低い点で、Set + を押します。
ポイント。 図4は、一番低いポイントを設定するためのカーソル位置を示します
レベルム用。 脳セグメンテーションのもう一つの入力はシードポイントです
白い問題は、それが白にある限り、あらゆるポイント使用することができます
問題(図5)。 Set +ボタンを押してカーソルをフェッチします
シードの座標。 他の入力は変数のです
分割アルゴリズムとデフォルト値が最も多い
画像。 脳のセグメンテーションの結果は、「脳」を選択することで見ることができます
マスク。

お問い合わせ 【図4】設定時のセグメンテーションのインターフェイス
レベルム用。 ]() NFT_cerebellarlowpoint.png "wikilink")...
お問い合わせ 【図5】種子点におけるセグメンテーションのインターフェイス
WM.(NFT_WMpointselection.png "wikilink")

### 外スクールセグメンテーション

アウタースカルセグメンテーションでは、アイロブのシードポイントを選択
ユーザーによる 目がはっきりと見えるスライスを選択したら
アキシアルビュー(図6)、Set +は、そのスライスを選択するために押されます。 開催期間
外部スカルセグメンテーション、イメージウィンドウはユーザーにポップアップします
両眼ローブをクリックします。 図 7 は、ポップアップがポップアップするマツラボ図を示しています
目ロブをクリックします。 目が外側の頭皮を選択したら
セグメント化し、「アウタースカルマスク」で見ることができます。

![図6:目が明確に観察される軸の切れを選ぶためのセグメンテーションのインターフェイス。](NFT_eyeselection.png "wikilink")


![図7: 目元をクリックするマトラボ図。](NFT_eyelobes.png "wikilink")

### インナースカルセグメンテーション

内部のskullの区分はユーザーの入力を必要としません。 アフター
内側の頭蓋骨は分割され、外側の頭蓋骨と頭皮がチェックされます。
交差か非常に薄い区域。 これらのマスクは、ある場合は修正されます
任意の交差する地域やあまりにも近い地域に適さない
BEMモデリング用

セグメントモジュールの出力は、MR画像とスカルプをフィルタリングし、
頭蓋骨、CSF、脳マスク。 結果を保存することができます。
Matlabのデータフォーマットのセグメンテーションのあらゆる段階。 フィルタリングされたMRイメージ
マトラボ形式で保存され、名前は2つの優先度で保存されます。
件名_name_filtered_images.mat。 マスクは構造で保存されます
名前が Subject_name_segments.mat になる Matlab の形式。
Matlabに読み込まれると、構造は次のようになります。

    セグム =

             scalpmask: [256x258x257 論理]
             脳マスク: [256x258x257 論理]
        アウタースカルマスク: [256x258x257 論理]
        内臓マスク: [256x258x257 論理]

メッシュ生成
---------------

現実的なヘッドモデリングの第2ステップはメッシュ生成です。 メッシュ
生成モジュールはセグメンテーションの結果を使用し、出力します
ヘッドのBEMメッシュ。 メインメニューからモジュールが呼び出されると、
メインメニューで選択したサブジェクト名とサブジェクトフォルダを使用します
分割ファイルの場合。 出力フォルダは Subject フォルダーに設定されます。
被写体名にメッシュ名を設定します。 変更可能
出力フォルダをロードし、異なるセグメンテーションをロードします。
モジュールをスタンドアローンメッシュ生成ツールとして使用できます。

メッシュ生成モジュールは3層または4層メッシュを生成します。
ユーザーが選択したレイヤー数を選択します。 3層メッシュは
頭皮、頭皮およびCSFによって分けられる頭皮、頭皮および脳領域
表面。 CSFと脳は単一の領域として考えられます。 4名様
層メッシュモデルスカルプ、頭蓋骨、CSF、脳領域、
CSFと脳を分離する追加の表面。

メッシュ生成のインターフェイスは図8に示されます。 生成された
メッシュファイルは、BEMソルバーから直接使用するのに適しています。 フォーマット
メッシュファイルには [付録A](NFT-Appendix-A.html "wikilink").
メッシュ生成プロセスは以下のとおりです。

![](NFT_from_MRI_mesh_gen.png "wikilink") .....
お問い合わせ [図8:メッシュのインターフェイス]
ジェネレーション ]() NFT_meshジェネレーション_ui.png "wikilink"


網の世代別モジュールは合う三角の網を作成します
セグメントの境界。 目的は幾何学を近づけることです
ランニングを防止するのに十分な三角形の小数を維持しながら
BEMソルバーのリソースから。 メッシュによるアプローチ
生成モジュールは表面の非常に良い網から始めることです
境界線、そして次第にそれを衝突し、トポロジーが正しいことを確かめて下さい
要素の品質は各ステップで高くなっています。

この目的のために、3つの外部プログラムとさまざまなMaatlab関数
使用しています。 外部プログラムは、適応型スケルトンクライミング(ASC)
(http://www.cse.cuhk.edu.hk/ttwong/papers/asc/asc.html) のための
トリアンギュレーション、Qslim (Qslim)http://mgarland.org/software/qslim.html)網のための
滑らかで、トポロジーの訂正のための粗く、およびShowmesh。
このプロセスを運転し、ローカルメッシュを行うMATLABで書かれた機能
精製。 ローカルメッシュの精錬の目的は、それが確実であることを確認することです
メッシュ間の距離は、エッジの長さと比較してあまり小さいではありません
隣接する要素。 この目的のために、長いエッジを持つ要素
エッジの長さが2つのローカル距離よりも大きい場合は、洗練された
隣接するメッシュは、ユーザが指定したLMR比で多岐に渡ります。 お問い合わせ
LMRを2の比率で適用することを提案しました。

メッシュ生成中にプログラムのステータスが書かれている
ウィンドウの下部とプログレスバーが進行状況を表示します
プログラム

源空間生成
-----------------------

源空間は、脳のボリューム内に置いたダイポールソースのセットです。
リードフィールド・マトリックス(LFM)を生成するために、ソース・スペースが使用されます。
ダイポールソースの強さを電極の電位にマップするマトリックスです。

フォワードモデリングツールボックスには、シンプルな生成オプションが含まれています。
通常のグリッドからなるソーススペース。 グリッドは生成されます
脳内の各グリッド位置で3つのオトゴナルダイポールを配置
ボリューム。 ユーザの入力は、ダイポールとの間の間隔です。
ダイポールから脳メッシュまでの最小距離。 間隔は決定します
2つのダイポール間の最小距離。 間隔のデフォルト値は 8 です
mm と、ダイポールの最小距離は 2 mm です。 お問い合わせ
デフォルトパラメータは、平均6000-7000ダイポールで結果します
大人の人間の脳。 このモジュールのユーザーインターフェイスは図に示されます
9. 出力ファイルはメインウィンドウで設定された出力フォルダに保存されます。
ソーススペースとして。 asciiのフォーマットですくいます。 ダイポールの数の行列です
6、各列のx、y、zの位置およびダイポールの方向は
お問い合わせ

単一のダイポールで通常のグリッドソーススペースを使用してLFMを使用することができます
対物問題の解決は粗い推定を見つけるために
ダイポールポジション。

![](NFT_from_MRI_source_space.png "wikilink") ..... 
![図9: ソース空間生成のためのインターフェイス。](NFT_sourcespacegen.png "wikilink")

電極の位置の調整
--------------------------------------

BEMメッシュは3D MRボリュームから生成され、同じ
ボリュームとしてシステムを調整します。 EEGの記録を扱うとき、
デジタイザで測定される電極座標は、
メッシュ座標。 このステップは、電極の共同登録と呼ばれます
場所。

電極の共同登録モジュールへの入力は電極です
場所。 被写体のスカルプメッシュが自動的にロードされ、
電極はスカルプメッシュに共同登録されます。 共同登録
2つのステップで行います。 ユーザが手動でセンサーを共同登録する
初期登録ボタンを押します。 EEGLABの始まり
共同登録機能および粗い登録は持って来るために行われます
メッシュ座標系へのセンサー 第2ステップは完了です
共同登録。 このステップは、初期の共同登録から始まり、
最高の翻訳と回転パラメータを自動的に見つける
センサーとスカルプ面のトータル距離を最小化。

共同登録のインターフェイスは図10で示されます。 終了時
各登録ステップ、登録した数字が表示されるポップアップ
頭皮の表面の電極。 いずれかの保存が可能です。
初期または完全な登録。 プログラムの出力は
頭皮の網の電極の登録された電極そして索引
地域。

セグメント化、メッシュ生成、およびソース空間の出力
必須項目です。 サブジェクト名は出力ファイルに使用されます。
ステージ。 一方、電極は毎回登録しなければなりません
電極の位置は変わります。 そのため、共同登録出力は
セッションの特定 電極の調整の結果は保存されます
session_Name_Subject_Name_headsensors.sens を ASCII 形式で指定します。

![](NFT_from_MRI_coreg.png "wikilink") .... 
![図10:共同登録のためのインターフェイス。](NFT_coregistration.png "wikilink")


テンプレートワーピングを使ったヘッドモデリング
------------------------------------

被写体のMR画像が利用できない場合、頻繁に使用される
アプローチは、テンプレートヘッドメッシュを使用し、電極をこれにマップすることです。
ソースのローカリゼーションのためのテンプレート。 MNIの脳は、
モントリオール神経科学研究所(MNI) 305頭MRIを平均化
通常の被写体は、この目的のために頻繁に使用されます。

Darvas et al \[1\] によって提案された代替アプローチは、
センサーの位置に合うテンプレートメッシュ。 このツールボックスはこれを実行します
MR画像がない場合、特定のヘッドモデルを生成する機能
可能です。 この結果は、より現実的なヘッドモデルと比較して
テンプレートメッシュを使用して、電極をマッピングします。 テンプレートモデル
このツールボックスで使用されているのは、抽出された3層のBEMメッシュです。
MNIの脳。

ワーピングは、表面に基づいて計算されます: 陰と左と
正しい項目のポイント。 これらの3ポイントを使用して、別のポイントは
テンプレートモデルの先頭に計算され、
被験者の電極の位置。 これらの4ポイントを使用して、センサー
位置とヘッドモデルが同じ座標系に持ち込まれています。 アフター
この初期の共同登録、ヘッドモデルと両方の19のランドマーク
センサーはあります。 これらのランドマークは、ワーピングを見つけるために使用されます
パラメータ。 ワーピング方式は、非厳格な薄版スプライン方式です。
頭皮、すべての表面および源のためのゆがみを見つけることの後で
スペースは同じゆがみパラメータを使用して警告されます。

ゆがみモジュールの入力は表面および電極です
位置(デジタルサイダーから取得) 出力は歪んだ網です、
歪んだ供給スペース、網の電極の徴候は、合いました
電極の場所とユーザが望む場合に警告パラメータ
テンプレートモデルにローカライズされたソースをバックアップします。 注意:
MNI の頭部がないので歪んだ電極の数が低下するかもしれません
ヘッドモデル全体で、いくつかの電極はテンプレートメッシュから落ちる可能性があります。

図11では、警告モジュールのインターフェイスが示されています。

![](NFT_from_Warping.png "wikilink") ..... 
![図11:テンプレートヘッドモデルのインターフェイスワーピング。](NFT_warping_ui.png "wikilink")

------------------------------------------------------------------------

参考文献

\[1\] F. Darvas、J.J. Ermer、J.C. Mosher、R.M. Leahy、ジェネリックヘッド
アトラスベースの EEG ソース分析、ヒト脳マッピング、vol.
27(2), 2005, PP 129-143.
